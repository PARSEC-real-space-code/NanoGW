#include "../shared/mycomplex.h"
! Compute the spectra function of Hermitian matrix using
! lanczos algorithm
! what we calculate is
!
!  <vec| 1/(z-H) |vec>
!
subroutine Zlanczos_spectra_isdf_lowcomsym(v0, ncv_loc, zz, nz, niter, isdf_in, sqrtR, polynomial, npoly, &
                                           spectra, tamm_d, blksz, nmrep, gvec &
#ifdef DCU
                                           , d_PsiV, d_PsiC, d_Cmtrx, d_pvec, d_cvec, d_lcrep, &
                                           hipblasHandle &
#elif defined _CUDA
                                           , d_PsiV, d_PsiC, d_Cmtrx, d_pvec, d_cvec, d_lcrep, &
                                           vstep, tmp_vec, streamid &
#endif
                                           )

  use typedefs
  use mpi_module

#ifdef DCU
  use hipfort_types
#elif defined _CUDA
  use cublas  ! required to use generic BLAS interface
  use cudafor ! CUDA runtime API routines (e.g. cudaDeviceSynchronize)
#endif

  implicit none
  include 'mpif.h'

  type(ISDF), intent(in) :: isdf_in
  type(gspace), intent(in) :: gvec
  logical, intent(in) :: tamm_d
  integer, intent(in) :: ncv_loc, niter, nz, npoly, blksz, nmrep
  real(dp), intent(in) :: polynomial(npoly + 1), sqrtR(ncv_loc)
  SCALAR, intent(in) :: v0(ncv_loc, blksz)
  complex(dpc), intent(in) :: zz(nz, blksz)
  complex(dpc), intent(out):: spectra(nz, blksz)
  real(dp) :: norm(blksz), norm_sq(blksz)
  !real(dp), target, intent(inout) :: MC_vec(w_grp%myn_intp_r, blksz), &
  !  CMC_vec(ncv_loc, blksz), tmp_vec(isdf_in%n_intp_r, blksz)

#ifdef DCU
  type(c_ptr), intent(inout) :: d_PsiV, d_PsiC, d_Cmtrx, d_cvec, d_pvec, d_lcrep
  type(c_ptr), intent(in) :: hipblasHandle
#elif defined _CUDA
  real(dp), device, intent(in) :: d_PsiV(isdf_in%n_intp_r, *), d_PsiC(isdf_in%n_intp_r, *)
  real(dp), device, intent(inout) :: d_Cmtrx(isdf_in%maxmync_sym*vstep, isdf_in%n_intp_r), &
                                     d_cvec(isdf_in%n_intp_r, blksz), &
                                     d_pvec(isdf_in%maxmync_sym*vstep, blksz)
  real(dp), intent(inout) :: tmp_vec(isdf_in%n_intp_r, blksz)
  integer, device, intent(in) :: d_lcrep(*)
  integer, intent(in) :: vstep
  integer(kind=cuda_stream_kind), intent(in) :: streamid
#endif

  SCALAR :: a_elmt(niter, blksz), a_tmp(blksz)
  real(dp) :: b_elmt(niter, blksz), b_tmp(blksz)
  complex(dpc) :: numerator, denominator
  integer :: ii, i, j, k, iz, info

#ifndef _CUDA
  SCALAR, external :: Zdot_c
#endif

  SCALAR :: vec(ncv_loc, blksz), wvec(ncv_loc, blksz), tmpvec(ncv_loc, blksz)

  ! Normalize v0
  do ii = 1, blksz
    norm_sq(ii) = real(Zdot_c(isdf_in%myncv_sym(nmrep), v0(1, ii), 1, v0(1, ii), 1), kind=dp)
  end do ! kk
  call MPI_ALLREDUCE(MPI_IN_PLACE, norm_sq, blksz, MPI_DOUBLE_PRECISION, MPI_SUM, peinf%comm, info)
  norm = sqrt(norm_sq)
  do ii = 1, blksz
    vec(1:ncv_loc, ii) = v0(1:ncv_loc, ii)/norm(ii)
  end do

  ! Initialization
  b_elmt(1, :) = one

  do k = 1, niter

    if (k > 1) then
      ! b = ||w||
      do ii = 1, blksz
        b_tmp(ii) = real(Zdot_c(ncv_loc, wvec(1, ii), 1, wvec(1, ii), 1), kind=dp)
      end do  ! ii
      call MPI_ALLREDUCE(MPI_IN_PLACE, b_tmp, blksz, MPI_DOUBLE_PRECISION, MPI_SUM, peinf%comm, info)
      b_elmt(k, :) = sqrt(b_tmp)

      ! tmp = - v b
      ! v = w / b
      do ii = 1, blksz
        tmpvec(1:ncv_loc, ii) = -vec(1:ncv_loc, ii)*b_elmt(k, ii)
        vec(1:ncv_loc, ii) = wvec(1:ncv_loc, ii)/b_elmt(k, ii)
      end do  ! ii
    end if

    ! w = H @ v
    if (tamm_d) then ! TDA - no poly fitting
      call Zmatvec_isdf_lowcomsym(vec, wvec, ncv_loc, isdf_in, sqrtR, .true., &
                                  blksz, nmrep, gvec &
#ifdef DCU
                                  , d_PsiV, d_PsiC, d_Cmtrx, d_pvec, d_cvec, d_lcrep, &
                                  hipblasHandle &
#elif defined _CUDA
                                  , d_PsiV, d_PsiC, d_Cmtrx, d_pvec, d_cvec, d_lcrep, &
                                  vstep, tmp_vec, streamid &
#endif
                                  )
    else ! not TDA - poly fitting
      call Zpolynomial_matvec_isdf_lowcomsym(vec, wvec, ncv_loc, polynomial, npoly, isdf_in, sqrtR, &
                                             blksz, nmrep, gvec &
#ifdef DCU
                                             , d_PsiV, d_PsiC, d_Cmtrx, d_pvec, d_cvec, d_lcrep, &
                                             hipblasHandle &
#elif defined _CUDA
                                             , d_PsiV, d_PsiC, d_Cmtrx, d_pvec, d_cvec, d_lcrep, &
                                             vstep, tmp_vec, streamid &
#endif
                                             )
    end if

    ! a = w* @ v
    do ii = 1, blksz
      a_tmp(ii) = Zdot_c(ncv_loc, wvec(1, ii), 1, vec(1, ii), 1)
    end do
    call MPI_ALLREDUCE(MPI_IN_PLACE, a_tmp, blksz, MPI_DOUBLE_SCALAR, MPI_SUM, peinf%comm, info)
    a_elmt(k, :) = a_tmp

    ! w = w - a v + tmp
    if (k < niter) then
      do ii = 1, blksz
        call Zaxpy(ncv_loc, -a_elmt(k, ii), vec(1, ii), 1, wvec(1, ii), 1)
      end do  ! ii
      if (k > 1) then
        wvec = wvec + tmpvec
      end if
    end if

  end do  ! k

  ! <vec| 1/(z-H) |vec>
  spectra = zzero
  do ii = 1, blksz
    do iz = 1, nz
      do j = niter, 1, -1
        numerator = b_elmt(j, ii) * b_elmt(j, ii) * zone
        ! if (j == 1) numerator = zone  ! This is done by setting b1 = 1
        denominator = zz(iz, ii) - a_elmt(j, ii) - spectra(iz, ii)
        spectra(iz, ii) = numerator/denominator
      end do  ! j
      spectra(iz, ii) = spectra(iz, ii) * norm_sq(ii)
    end do  ! iz
  end do  ! ii

end subroutine

