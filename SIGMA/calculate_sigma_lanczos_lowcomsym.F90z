#include "../shared/mycomplex.h"
!===================================================================
!
! Calculate G0W0 self-energy using lanczos iterations
!
! Author: Weiwei Gao @ Dalian Univ. of Tech.
!
!---------------------------------------------------------------
subroutine Zcalculate_sigma_lanczos_lowcomsym (nspin, nkpt, sig_en, dft_code, &
    gvec, kpt, qpt, k_c, k_p, sig_in, sig, q_p, nolda, tamm_d, writeqp, snorm, &
    cohsex, ecuts, sig_cut, max_sig, isdf_in, doisdf, opt)

  use typedefs
  use mpi_module
#ifdef DCU
  use sub_module
  use hipfort
  use hipfort_check
  use hipfort_types
  use hipfort_hipblas
#endif

#ifdef _CUDA
  ! Need to include a couple of modules:
  !   cublas: required to use generic BLAS interface
  !   cudafor: required to use CUDA runtime API routines 
  !       (e.g. cudaDeviceSynchronize)
  !       not explicitly required if file has *.cuf suffix 
  use cublas
  use cudafor
#endif
  implicit none
#ifdef MPI
  include 'mpif.h'
#endif

  ! arguments
  integer, intent(in) :: &
      nspin, &    ! number of spin channels
      nkpt, &     ! number of k-points where self-energy is computed
      sig_en, &   ! number of energy values where self-energy is computed
      dft_code    ! choice of DFT code
  ! real-space grid
  type (gspace), intent (inout) :: gvec
  ! k-points and wavefunctions, q-space in TDLDA
  type (kptinfo), intent (inout) :: kpt
  type (qptinfo), intent (inout) :: qpt
  type (kernelinfo), dimension (gvec%syms%ntrans,qpt%nk), intent(inout) :: &
      k_c, &      ! kernel for correlation, vertex
      k_p         ! kernel for TDLDA
  ! input self-energy data
  type (siginfo), intent (inout) :: sig_in
  ! self-energy data
  type (siginfo), dimension (nspin,nkpt), intent(inout) :: sig
  ! quasi-particle data
  type (qpinfo), dimension (gvec%syms%ntrans,nspin,nkpt), intent (inout) :: q_p

  logical, intent(in) :: &
      nolda, &    ! true if LDA kernel is not used
      tamm_d, &   ! true if Tamm-Dancof approximation is used
      writeqp, &  ! true if QP wavefunctions are printed in file parsec_qp.dat
      snorm, &    ! true if sum rule is renormalized
      cohsex      ! true if self-energy is computed within the COHSEX approximation

  real (dp), intent (in) :: &
      ecuts, &    ! resolution in energy denominators, in Ry
      sig_cut     ! cut-off in self-energy corrections
  ! maximum amplitude of self-energy correction
  real (dp), intent (out) :: max_sig
  ! Additional input parameters for ISDF method
  type (ISDF), intent (inout) :: isdf_in
  logical, intent (in) :: doisdf
  type (options), intent (in) :: opt
  ! local variables
  character (len=100) :: file_name

  logical :: staticcorr
  integer :: ii, jj, irp, jrp, iq, ik, jk,  isp,  isig, info, chkpt, neig_qp, &
      ien, n_intp_loc, ic, iv, icv, icv_start, icv_end, intp_start, intp_end, &
      ij, incr, jn, m1, ncv, ncv_loc, iprocs, inode, ipe, ldncv, mycv_end, &
      mycv_start, myn_intp_end, myn_intp_start, myn_intp_r, myncv, this_ncv, &
      jnend, npoly, ncond, nval, jnblock
  real (dp) :: tsec(2), xsum, rtmp, epsinv, deltae, emin, emax, en0, res
  real (dp), allocatable :: polynomial(:), Pvec(:,:), tmp_Cmtrx(:,:), &
      tmp_CvecM(:,:), tmp_poly(:), sqrtR(:), tmp_Cvec(:,:), tmparray(:,:)
  integer, allocatable :: iord(:) !, cvpair(:,:)
  integer, parameter :: it_scf = 0
  real (dp), parameter :: qpmix = 1.d0
  complex (dp), allocatable :: zz(:), ezz(:,:), sigma_corr(:), &
      sigma_corr_tmp(:,:)
  ! -------- temporary arrays for lanczos iterations --------
  integer :: tmp_cvpair(2,w_grp%ldncv), irep, kk, blksz, iblk, cvstart, jc, &
      jv, jvrep, jcrep, istart, ivstart, icstart, lncond, lnval, m1_rep, &
      maxnblks, nmrep, ibnd, irp1, irp2, lrp1, lrp2, nx, nx_select
  integer :: n_intp_r, icend
  integer, allocatable :: blks(:,:,:), tmp_lrep(:,:), tmp_lvrep(:,:), &
      tmp_lcrep(:,:), nvblks(:), nblks(:), ncblks(:), tmp_count(:)
  real (dp) :: pnorm2(opt%jnblock), pnorm(opt%jnblock), fit_error, max_fit_error
  !real(dp) :: MC_vec(w_grp%myn_intp_r, opt%jnblock), &
  !  CMC_vec(w_grp%ldncv, opt%jnblock), &
  !  tmp_vec(isdf_in%n_intp_r, opt%jnblock)
  !real(dp), target, allocatable :: MC_vec(:,:), CMC_vec(:,:), &
  !   tmp_vec(:,:)
  ! ---------------------------------------------------------
#ifndef _CUDA
  real (dp), external :: ddot
#endif
#ifdef DCU
  real (dp), parameter :: d_one = 1.d0, d_zero = 0.d0
  type (c_ptr) :: d_PsiV, d_PsiC, d_Cmtrx, d_cvec, d_pvec, d_lcrep
  type (c_ptr) :: handle = c_null_ptr
  integer (kind(HIPBLAS_OP_N)), parameter :: &
    transt = HIPBLAS_OP_T, &
    transn = HIPBLAS_OP_N
  !integer :: ndevs, mydevice
  integer (c_size_t), parameter :: Bytes_double = 8
  integer (c_size_t) :: Nbytes

  call hipblasCheck(hipblasCreate(handle))
#endif
#ifdef _CUDA
  integer :: istat, vstep, voffset, v_incr_end, v_incr
  integer :: ndevs, mydev
  type (cublasHandle) :: handle
  real (dp), device, dimension (:,:), allocatable :: d_PsiV, d_PsiC, d_Cmtrx, &
      d_cvec, d_pvec 
  integer, device, dimension (:), allocatable :: d_lcrep
  integer (kind=cuda_stream_kind) :: streamid
#endif

#ifdef DEBUG
  integer :: dbgunit = 111112
#endif

#ifdef DEBUG
  ! WG: for debug
  if (peinf%master) open(dbgunit,file="gw_corre_incr.dat",form='formatted')
#endif

  if (peinf%master) print *, "ecuts ", ecuts
  !-------------------------------------------------------------------
  ! Prepare to calculate self-energy.
  !
  staticcorr = .false.
  
  if (nspin /= 1) then
    call die("For now, GW lanczos is only implemented for nspin = 1.")
  end if
  if (nkpt /= 1)  then
    call die("For now, GW lanczos is only implemented for nkpt = 1.")
  end if
  if (peinf%num /= 1) then
    call die(" GW lanczos is only implemented for 1 peinf group.")
  end if
  if (peinf%master) then
    print *, " lanczos niter = ", opt%lanczos_niter, " polynomial degree = ", &
        opt%lanczos_npoly
  end if
  jnblock = opt%jnblock 
  if (peinf%master) print *, " jnblock = ", jnblock

  do ik = 1, nkpt
    do isp = 1, nspin
      if (sig(isp,ik)%ndiag_s > 0) then
        sig(isp,ik)%xdiag = zzero
        sig(isp,ik)%scsdiag = zzero
      end if
      if (sig(isp,ik)%noffd_s > 0) then
        sig(isp,ik)%xoffd = zzero
        sig(isp,ik)%scsoffd = zzero
      end if
      if (sig_in%xc == XC_GW) then
        if (sig(isp,ik)%ndiag > 0) then
          sig(isp,ik)%scdiag = zzero
          sig(isp,ik)%sexdiag = zzero
          sig(isp,ik)%sgdiag = zzero
        end if
        if (sig(isp,ik)%ndiag_s > 0) sig(isp,ik)%sgsdiag = zzero
        if (sig(isp,ik)%noffd > 0) then
          sig(isp,ik)%scoffd = zzero
          sig(isp,ik)%sgoffd = zzero
        end if
        if (sig(isp,ik)%noffd_s > 0) sig(isp,ik)%sgsoffd = zzero
      end if
    end do ! isp
  end do ! ik

  !-------------------------------------------------------------------
  ! Calculate bare exchange part of self-energy.
  !
  !if (chkpt < (qpt%nk + 1) * gvec%syms%ntrans) then
  call stopwatch(r_grp%master,' Calling exchange ')
  do ik = 1, nkpt
    do isp = 1, nspin
      jk = sig(isp,ik)%indxk
      call timacc(6, 1, tsec)
      if (sig_in%xc == XC_GW .or. sig_in%xc == XC_HF .or. &
          sig_in%xc == XC_B3LYP) &
          call Zfock_exchange(gvec, kpt, sig(isp,ik), isp, jk)
      call timacc(6, 2, tsec)
    end do ! isp
  end do ! ik
  !endif

#ifdef _CUDA
  istat = cudaGetDeviceCount(ndevs)
  mydev = mod(peinf%inode, ndevs)
  if (ndevs > 0) then
    istat = cudaSetDevice(mydev)
    !print *, peinf%inode, "finished set device"
    !do ipe = 0, peinf%npes-1
    !if ( peinf%inode .eq. ipe ) then
    !   print *, "inode ", peinf%inode, " ndevs ", ndevs, " mydev ", mydev, istat
    !endif
    !enddo ! 
  end if

  istat = cublasCreate(handle)
  istat = cublasgetstream(handle, streamid)
  !do ipe = 0, peinf%npes-1
  !   if ( peinf%inode .eq. ipe ) then
  !      print *, " inode ", peinf%inode, " create cublashandle", istat
  !   endif
  !enddo
#endif

  if (sig_in%xc == XC_GW) then
    ! deallocate unused arrays
    
    do iq = 1, qpt%nk
      do irp = 1, gvec%syms%ntrans
        !deallocate(k_p(irp,iq)%col)
        !! if lessmemory .eq. 4 we did not allocate k_p%col ... in define
        !deallocate(k_p(irp,iq)%row)
        !! if lessmemory .eq. 4 we did not allocate k_p%col ... in define
        !deallocate(k_c(irp,iq)%col)
        !deallocate(k_c(irp,iq)%row)
      end do
    end do
    inode = w_grp%inode
    ncv = w_grp%ncv
    myn_intp_start = w_grp%n_intp_start(inode)
    myn_intp_end = w_grp%n_intp_end(inode)
    myn_intp_r = w_grp%myn_intp_r
    n_intp_r = isdf_in%n_intp_r
    !
    allocate (tmp_count(gvec%syms%ntrans))
    allocate (zz(sig_in%nen))
    allocate (ezz(sig_in%nen+1, jnblock))
    !
    npoly = opt%lanczos_npoly
    allocate (polynomial(npoly+1)) 
    allocate (tmp_poly(npoly+1)) 
    ! fit a polynomial
    nval = sum(kpt%wfn(1,1)%occ0) ! only works for systems with a gap
    ncond = kpt%wfn(1,1)%nmem - nval
    ! kpt%wfn(1,1)%nmem == isdf_in%maxicc ??
    if (peinf%master) then
      emin = (kpt%wfn(1,1)%e1(nval+1)-kpt%wfn(1,1)%e1(nval))**2.0 / 1.25d0
      emax = (kpt%wfn(1,1)%e1(isdf_in%maxicc)-kpt%wfn(1,1)%e1(1))**2.0 * 1.25d0
      print *, "emin = ", emin, " emax = ", emax
      !call polyfit_sqrt(emin, emax, npoly, 20, peinf%inode, tmp_poly, .False.)
      ! search for best polynomial fitting 
      max_fit_error = 1e3
      do nx = 20, 300, 20
        call polyfitcheb_sqrt(emin, emax, npoly, nx, peinf%inode, tmp_poly, &
            fit_error, .False.)
        if (fit_error .lt. max_fit_error) then
          nx_select = nx
          do ii = 1, npoly+1
            polynomial(ii) = tmp_poly(npoly+2-ii)
          end do ! ii
        end if
      end do ! nx
    end if
    if (peinf%master) print *, "Use ", nx_select, &
        " points to fit polynomial. Relative error: ", fit_error
    !if (peinf%master) print *, "polynomial ", polynomial(1:(npoly+1))
    call MPI_BCAST(polynomial, npoly+1, MPI_DOUBLE, peinf%masterid, &
        peinf%comm, ii)
    ! redistribute 
    !if (peinf%master) print *, "Redistribute Psi_intp_loc to PsiV_intp_bl and PsiC_intp_bl"
    call Zredistribute_Psi_loc(isdf_in, nval, ncond)
    !
    !-------------------------------------------------------------------
    ! Calculate correlation and vertex. Must reset the file with
    ! polarizability eigenvectors.
    !
    ! Todo: currently, gw_lanczos only support qpt%nk = 1 and r_grp%num = 1
    ! Todo: gw_lanczos for vertex part
    ! Prepare C^\nu_{vc}
    ! k_p(1,1)%col(1,ij) --> valance band index
    ! k_p(1,1)%col(2,ij) --> conduction bands index
    ! determine the local (v,c) pairs
    !
    !allocate(cvpair(2, myncv))
    !cvpair(1:2, 1:myncv) = &
    !  k_p(1,1)%col(1:2, mycv_start:mycv_end)
    ! local number of interpolation points
    myncv = isdf_in%mynv * isdf_in%mync
    ! prepare indices for symmetry representations
    allocate(tmp_lrep(kpt%wfn(1,1)%nmem, gvec%syms%ntrans))
    allocate(tmp_lvrep(isdf_in%mynv, gvec%syms%ntrans))
    allocate(tmp_lcrep(isdf_in%mync, gvec%syms%ntrans))
    allocate(isdf_in%lrep (kpt%wfn(1,1)%nmem))
    allocate(isdf_in%lvrep(isdf_in%mynv))
    allocate(isdf_in%lcrep(isdf_in%mync))
    allocate(isdf_in%lrep_bound (gvec%syms%ntrans,3))
    allocate(isdf_in%lvrep_bound(gvec%syms%ntrans,2))
    allocate(isdf_in%lcrep_bound(gvec%syms%ntrans,2))
    tmp_lrep  = 0
    tmp_lvrep = 0
    tmp_lcrep = 0
    isdf_in%lrep  = 0
    isdf_in%lvrep = 0
    isdf_in%lcrep = 0
    isdf_in%lrep_bound  = 0
    isdf_in%lvrep_bound = 0
    isdf_in%lcrep_bound = 0

    ! tmp_lrep (:, 1:ntrans)
    ! tmp_lvrep(:, 1:ntrans)
    ! tmp_lcrep(:, 1:ntrans)

    ! isdf_in%lrep_bound(irp, 1)   1:kpt%wfn(1,1)%nmem
    ! isdf_in%lrep_bound(irp, 2)   1:mynv
    ! isdf_in%lrep_bound(irp, 3)   1:mync
    ! isdf_in%lvrep_bound(irp, 1)
    ! isdf_in%lvrep_bound(irp, 2)
    ! isdf_in%lcrep_bound(irp, 1)
    ! isdf_in%lcrep_bound(irp, 2)

    do ibnd = 1, kpt%wfn(1,1)%nmem
      do irp = 1, gvec%syms%ntrans
      if ( kpt%wfn(1,1)%irep(ibnd) .eq. irp ) then
        isdf_in%lrep_bound(irp,2) = isdf_in%lrep_bound(irp,2)+1
        if (ibnd .le. nval) then
          isdf_in%lrep_bound(irp,3) = isdf_in%lrep_bound(irp,3)+1
        endif
        tmp_lrep(isdf_in%lrep_bound(irp,2), irp) = ibnd
        if (ibnd .le. isdf_in%myvend .and. ibnd .ge. isdf_in%myvstart) then
          isdf_in%lvrep_bound(irp,2) = isdf_in%lvrep_bound(irp,2)+1
          tmp_lvrep(isdf_in%lvrep_bound(irp,2), irp) = ibnd-isdf_in%myvstart+1
        endif
        if (ibnd .le. isdf_in%mycend+nval .and. ibnd .ge. isdf_in%mycstart+nval) then
          isdf_in%lcrep_bound(irp,2) = isdf_in%lcrep_bound(irp,2)+1
          tmp_lcrep(isdf_in%lcrep_bound(irp,2), irp) = ibnd-(isdf_in%mycstart+nval)+1
        endif
      endif ! 
      enddo ! irp
    enddo ! ibnd

    ! isdf_in%lrep ( lrep_bound(1,irp):lrep_bound(2,irp) ): the band index for representation irp, Psi_intp_loc(myn_intp_r, nmem)
    ! isdf_in%lvrep( lvrep_bound(1,irp):lvrep_bound(2,irp) ): the index of states of representation irp, stored in PsiV_intp_bl(n_intp_r, mynv)
    ! isdf_in%lcrep( lcrep_bound(1,irp):lvrep_bound(2,irp) ): the index of states of representation irp, PsiC_intp_bl(n_intp_r, mync)
    do irp = 1, gvec%syms%ntrans

      if (irp .eq. 1) then
        istart  = 0
        ivstart = 0
        icstart = 0
      else
        istart  = isdf_in%lrep_bound (irp-1, 2)
        ivstart = isdf_in%lvrep_bound(irp-1, 2)
        icstart = isdf_in%lcrep_bound(irp-1, 2)
      endif
      !
      isdf_in%lrep(istart+1:istart+isdf_in%lrep_bound(irp, 2)) = &
        tmp_lrep(1:isdf_in%lrep_bound(irp, 2), irp)
      isdf_in%lrep_bound(irp, 1) = istart+1
      isdf_in%lrep_bound(irp, 2) = istart+isdf_in%lrep_bound(irp, 2)
      isdf_in%lrep_bound(irp, 3) = istart+isdf_in%lrep_bound(irp, 3)
      !
      isdf_in%lvrep(ivstart+1:ivstart+isdf_in%lvrep_bound(irp, 2)) = &
        tmp_lvrep(1:isdf_in%lvrep_bound(irp, 2), irp)
      isdf_in%lvrep_bound(irp, 1) = ivstart+1
      isdf_in%lvrep_bound(irp, 2) = ivstart+isdf_in%lvrep_bound(irp, 2)
      !
      isdf_in%lcrep(icstart+1:icstart+isdf_in%lcrep_bound(irp, 2)) = &
        tmp_lcrep(1:isdf_in%lcrep_bound(irp, 2), irp)
      isdf_in%lcrep_bound(irp, 1) = icstart+1
      isdf_in%lcrep_bound(irp, 2) = icstart+isdf_in%lcrep_bound(irp, 2)

    enddo ! irp

    deallocate (tmp_lrep)
    deallocate (tmp_lvrep)
    deallocate (tmp_lcrep)
    allocate (isdf_in%ncv_sym(gvec%syms%ntrans))
    allocate (isdf_in%myncv_sym(gvec%syms%ntrans))
    allocate (isdf_in%mync_sym(gvec%syms%ntrans))
    allocate (isdf_in%mynv_sym(gvec%syms%ntrans))
    isdf_in%ncv_sym = 0
    isdf_in%myncv_sym = 0
    isdf_in%mync_sym = 0
    isdf_in%mynv_sym = 0
    do irep = 1, gvec%syms%ntrans
      isdf_in%mync_sym(irep) = isdf_in%lcrep_bound(irep,2) &
          - isdf_in%lcrep_bound(irep,1) + 1
      isdf_in%mynv_sym(irep) = isdf_in%lvrep_bound(irep,2) &
          - isdf_in%lvrep_bound(irep,1) + 1
    end do ! irep
    do irep = 1, gvec%syms%ntrans

      do lrp1 = 1, gvec%syms%ntrans
        do lrp2 = 1, gvec%syms%ntrans
          if (gvec%syms%prod(lrp1, lrp2) == irep) exit
        end do ! lrp2
        isdf_in%myncv_sym(irep) = isdf_in%myncv_sym(irep) + &
            (isdf_in%lvrep_bound(lrp1,2) - isdf_in%lvrep_bound(lrp1,1) + 1) * &
            (isdf_in%lcrep_bound(lrp2,2) - isdf_in%lcrep_bound(lrp2,1) + 1)
        isdf_in%ncv_sym(irep) = isdf_in%ncv_sym(irep) + &
            (isdf_in%lrep_bound(lrp1,3) - isdf_in%lrep_bound(lrp1,1) + 1) * &
            (isdf_in%lrep_bound(lrp2,2) - isdf_in%lrep_bound(lrp2,3))
        ! lrep_bound(:,2) largest empty state index
        ! lrep_bound(:,3) largest occupied state index

      end do ! lrp1
    end do ! irep
    call MPI_ALLREDUCE(isdf_in%myncv_sym, tmp_count, gvec%syms%ntrans, &
        MPI_INTEGER, MPI_SUM, peinf%comm, info)
    !do ipe = 0, peinf%npes-1
    !  if (peinf%inode .eq. ipe) then
    !    print *, " inode ", peinf%inode
    !    print *, " myvstart myvend mynv ", isdf_in%myvstart, isdf_in%myvend, isdf_in%mynv
    !    print *, " mycstart mycend mync ", isdf_in%mycstart, isdf_in%mycend, isdf_in%mync
    !    print *, " myncv ", isdf_in%mync*isdf_in%mynv
    !    do irp = 1, gvec%syms%ntrans
    !      print *, " isym ", irp
    !      print *, " lrep_bound ", isdf_in%lrep_bound(irp, 1:3)
    !      print *, " lvrep_bound ", isdf_in%lvrep_bound(irp, 1:2), isdf_in%mynv_sym(irp)
    !      print *, " lcrep_bound ", isdf_in%lcrep_bound(irp, 1:2), isdf_in%mync_sym(irp)
          !do kk = isdf_in%lrep_bound(irp,1), isdf_in%lrep_bound(irp,2)
          !  print *, " kk lrep ", kk, isdf_in%lrep(kk)
          !enddo
    !      print *, " myncv_sym ", isdf_in%myncv_sym(irp)
    !    enddo
    !  endif
    !  call MPI_BARRIER(peinf%comm, info)
    !enddo ! ipe
    !if (peinf%master) then
    !do irep = 1, gvec%syms%ntrans
    !  if(tmp_count(irep) .ne. isdf_in%ncv_sym(irep)) then
    !    print *, irep, " tmp_count ", tmp_count(irep), &
    !      " ncv_sym ", isdf_in%ncv_sym(irep) 
    !  endif
    !enddo
    !endif
    isdf_in%maxmyncv_sym = maxval(isdf_in%myncv_sym)
    isdf_in%maxmync_sym = maxval(isdf_in%mync_sym)
    isdf_in%maxmynv_sym = maxval(isdf_in%mynv_sym)
    allocate (tmp_Cvec(isdf_in%n_intp_r,jnblock))
    allocate (tmp_CvecM(myn_intp_r,jnblock))
    allocate (sqrtR(isdf_in%maxmyncv_sym))
    allocate (tmp_Cmtrx(isdf_in%maxmync_sym,isdf_in%n_intp_r))
#ifdef _CUDA
    vstep = 12000**2/isdf_in%maxmync_sym/isdf_in%n_intp_r
    if (vstep .le. 0) vstep = 1
    if (vstep .gt. isdf_in%maxmynv_sym) vstep = isdf_in%maxmynv_sym
    if (peinf%master) print *, " vstep ", vstep, " maxmync_sym ", &
        isdf_in%maxmync_sym, " n_intp_r ", isdf_in%n_intp_r, " maxmynv_sym ", &
        isdf_in%maxmynv_sym
    allocate (tmparray(vstep*isdf_in%maxmync_sym,jnblock))
#else
    allocate (tmparray(isdf_in%maxmync_sym,jnblock))
#endif
#ifdef DCU
    call hipCheck(hipMalloc(d_PsiV,  sizeof(isdf_in%PsiV_intp_bl) ))
    call hipCheck(hipMalloc(d_PsiC,  sizeof(isdf_in%PsiC_intp_bl) ))
    call hipCheck(hipMalloc(d_Cmtrx, sizeof(tmp_Cmtrx) ))
    call hipCheck(hipMalloc(d_cvec,  sizeof(tmp_Cvec) )) ! n_intp_r, jnblock
    call hipCheck(hipMalloc(d_pvec,  sizeof(tmparray) )) ! mync, jnblock
    call hipCheck(hipMalloc(d_lcrep, sizeof(isdf_in%lcrep) ))
    ! copy PsiV_intp_bl, PsiC_intp_bl and vec to device
    call hipCheck(hipMemcpy(d_PsiV, c_loc(isdf_in%PsiV_intp_bl), &
        sizeof(isdf_in%PsiV_intp_bl), hipMemcpyHostToDevice))
    call hipCheck(hipMemcpy(d_PsiC, c_loc(isdf_in%PsiC_intp_bl), &
        sizeof(isdf_in%PsiC_intp_bl), hipMemcpyHostToDevice))
    call hipCheck(hipMemcpy(d_lcrep, c_loc(isdf_in%lcrep), &
        sizeof(isdf_in%lcrep), hipMemcpyHostToDevice))
#endif
#ifdef _CUDA
    allocate (d_PsiV, source = isdf_in%PsiV_intp_bl(:,:,1,1))
    allocate (d_PsiC, source = isdf_in%PsiC_intp_bl(:,:,1,1))
    allocate (d_lcrep, source = isdf_in%lcrep)
    allocate (d_Cmtrx(isdf_in%maxmync_sym*vstep, isdf_in%n_intp_r))
    allocate (d_cvec(isdf_in%n_intp_r, jnblock))
    allocate (d_pvec(isdf_in%maxmync_sym*vstep, jnblock))
#endif

    allocate(nvblks(gvec%syms%ntrans))
    allocate(ncblks(gvec%syms%ntrans))
    allocate(nblks(gvec%syms%ntrans))
    do irep = 1, gvec%syms%ntrans
      lnval = isdf_in%lrep_bound(irep,3) - isdf_in%lrep_bound(irep,1) + 1
      nvblks(irep) = lnval/jnblock
      if (mod(lnval, jnblock) > 0) nvblks(irep) = nvblks(irep) + 1
      lncond = isdf_in%lrep_bound(irep,2) - isdf_in%lrep_bound(irep,3)
      ncblks(irep) = lncond/jnblock
      if (mod(lncond, jnblock) > 0) ncblks(irep) = ncblks(irep) + 1
      !print *, ncblks
      nblks(irep) = ncblks(irep) + nvblks(irep)
    end do ! irep
    maxnblks = maxval(nblks)
    allocate (blks(maxnblks,3,irep))
    blks = 0
    ! blks(kk, 1, irep) : start index of isdf_in%lrep
    ! blks(kk, 2, irep) : end index of isdf_in%lrep
    do irep = 1, gvec%syms%ntrans
      lnval = isdf_in%lrep_bound(irep,3) - isdf_in%lrep_bound(irep,1) + 1
      lncond = isdf_in%lrep_bound(irep,2) - isdf_in%lrep_bound(irep,3) 
      if (nvblks(irep) >= 1) then
        do kk = 1, lnval/jnblock
          blks(kk,1,irep) = (kk-1)*jnblock+1
          blks(kk,2,irep) = kk*jnblock
          blks(kk,3,irep) = 1
        end do ! kk
      end if 
      if (mod(lnval, jnblock) > 0) then
        blks(nvblks(irep),1,irep) = (nvblks(irep)-1)*jnblock+1
        blks(nvblks(irep),2,irep) = lnval
        blks(nvblks(irep),3,irep) = 1
      end if
      if (ncblks(irep) >= 1) then
       do kk = 1, lncond/jnblock
         blks(nvblks(irep)+kk,1,irep) = lnval+(kk-1)*jnblock+1
         blks(nvblks(irep)+kk,2,irep) = lnval+kk*jnblock
         blks(nvblks(irep)+kk,3,irep) = 0
       end do ! kk
      end if
      if (mod(lncond, jnblock) > 0) then
        blks(nblks(irep),1,irep) = lnval+(ncblks(irep)-1)*jnblock+1
        blks(nblks(irep),2,irep) = lnval+lncond
        blks(nblks(irep),3,irep) = 0
      end if
      if (w_grp%master) then
        print *, " ncblks nvblks ", ncblks(irep), nvblks(irep)
        print *, " idx   blks "
        do kk = 1, nblks(irep)
          print *, kk, blks(kk, 1:3, irep)
        end do ! kk
      end if
    end do ! irep
    allocate (sigma_corr_tmp(sig_in%nen+1,jnblock))
    allocate (sigma_corr(sig_in%nen))
    deltae = sig_in%deltae / (sig_in%nen - 1) ! in rydberg
    do ik = 1, nkpt  
      do isp = 1, nspin
        do isig = 1, sig_in%ndiag
          sigma_corr = 0.d0
          m1 = sig_in%map(sig_in%diag(isig))
          en0 = kpt%wfn(isp,ik)%e1(m1) - sig_in%deltae*half
          do ien = 1, sig_in%nen
            zz(ien) = deltae*(ien-1) + en0
          end do ! ien energy index
          do irep = 1, gvec%syms%ntrans

            m1_rep = kpt%wfn(1,1)%irep(m1)
            nmrep = gvec%syms%prod(irep,m1_rep)
            allocate (Pvec(isdf_in%myncv_sym(nmrep),jnblock))

            ! prepare sqrtR
            icv = 0
            do jvrep = 1, gvec%syms%ntrans
              do iv = isdf_in%lvrep_bound(jvrep,1), isdf_in%lvrep_bound(jvrep,2)
                jv = isdf_in%lvrep(iv) + isdf_in%myvstart - 1
                do jcrep = 1, gvec%syms%ntrans
                  if (gvec%syms%prod(jcrep, jvrep) .eq. nmrep) exit
                end do ! jcrep
                do ic = isdf_in%lcrep_bound(jcrep,1), isdf_in%lcrep_bound(jcrep,2)
                  jc = isdf_in%lcrep(ic) + isdf_in%mycstart + nval - 1
                  icv = icv + 1
                  sqrtR(icv) = (kpt%wfn(1,1)%e1(jc) - kpt%wfn(1,1)%e1(jv))**0.5
                end do ! ic
              end do ! iv loop
            end do ! jvrep loop
            do iblk = 1, nblks(irep)
              ! ----------------------------------------------------------------
              ! prepare vector |P_mn>
              ! m is the band which we want to compute its GW quasiparticle energy
              ! n is the band appear in the summation-over-band
              ! |P_mn> = \sum_{vc} (mn|vc) (e_c-e_v)^1/2 |vc>
              ! (mn|vc) (e_c-e_v)^1/2 
              !  = \sum_{\mu} C^\mu_{mn} (\mu|\nu) C^\nu_{vc} (e_c-e_v)^1/2
              ! where:
              ! C^\mu_{mn} = Psi_intp(\mu,m) * Psi_intp(\mu,n)
              ! (\mu|\nu) = Mmtrx(:, :)
              ! C^\nu_{vc} = Psi_intp(\nu,v) * Psi_intp(\nu,c)
              ! perform lanczos iteration to find the spectra
              ! function

              ! prepare C^\mu_{mn}
              ! m1 is the index of states which GW energy is calculated
              ! jn is sum over bands
              jn    = blks(iblk, 1, irep) + isdf_in%lrep_bound(irep,1) - 1
              jnend = blks(iblk, 2, irep) + isdf_in%lrep_bound(irep,1) - 1
              blksz = jnend - jn + 1
              call stopwatch(peinf%master, " prepare Pvec ")
              tmp_Cvec = 0.d0
              do kk = 1, blksz
                jk = isdf_in%lrep(jn+kk-1) 
                tmp_Cvec(myn_intp_start:myn_intp_end, kk) = &
                    isdf_in%Psi_intp_loc(1:myn_intp_r, m1, 1, 1) * &
                    isdf_in%Psi_intp_loc(1:myn_intp_r, jk, 1, 1)
              end do ! kk
              !if (w_grp%npes .gt. 1) then
              call MPI_ALLREDUCE(MPI_IN_PLACE, tmp_Cvec, &
                  isdf_in%n_intp_r*blksz, MPI_DOUBLE, MPI_SUM, peinf%comm, info)
              !endif
              !if (w_grp%master) print *, "tmp_Cvec", tmp_Cvec(1:10, 1), "nmrep", nmrep
              ! Compute tmp_CvecM(1:n_intp_loc)
              ! = tmp_Cvec(1, n_intp_r) @ Mmtrx(1:n_intp_r, intp_start:intp_end) 
              ! or 
              ! = Mmtrx(intp_start:intp_end, 1:n_intp_r) @ tmp_Cvec(n_intp_r)
              !call dgemv( 'N', myn_intp_r, isdf_in%n_intp_r, 1.d0, &
              !  isdf_in%Mmtrx_loc(1, 1, 1, 1, 1, 1, 1), myn_intp_r, &
              !  tmp_Cvec, 1, 0.d0, tmp_CvecM, 1 )
              call dgemm('N', 'N', myn_intp_r, blksz, isdf_in%n_intp_r, 1.d0, &
                  isdf_in%Mmtrx_loc(1,1,1,1,1,1,nmrep), myn_intp_r, tmp_Cvec, &
                  isdf_in%n_intp_r, 0.d0, tmp_CvecM, myn_intp_r)
              tmp_Cvec = 0.d0
              tmp_Cvec(myn_intp_start:myn_intp_end,1:blksz) = &
                  tmp_CvecM(1:myn_intp_r,1:blksz)
              call MPI_ALLREDUCE(MPI_IN_PLACE, tmp_Cvec, &
                  isdf_in%n_intp_r*blksz, MPI_DOUBLE, MPI_SUM, peinf%comm, info)
              !if (peinf%master) print *, "  tmp_CvecM(:, 1) ", tmp_Cvec(1:10, 1)
              !if (peinf%master) print *, "  tmp_CvecM(:, 1) ", tmp_Cvec(1:10, 2)
              ! Pvec stores the icv_start to icv_end elements of the global_Pvec
              ! compute Pvec(1:ncv_loc) = tmp_Cvec(1:isdf_in%n_intp_r)*tmp_Cmtrx(1:isdf_in%n_intp_r, 1:ncv_loc)
              Pvec = 0.d0 ! initialize Pvec with zeros
              ! call dgemv('T', isdf_in%n_intp_r, ncv_loc, 1.d0, tmp_Cmtrx, isdf_in%n_intp_r, tmp_Cvec, 1, 0.d0, Pvec, 1)
              cvstart = 0
#ifdef _CUDA
              v_incr = 0
#endif
              do jvrep = 1, gvec%syms%ntrans
                do iv = isdf_in%lvrep_bound(jvrep,1), &
                    isdf_in%lvrep_bound(jvrep,2)
                  jv = isdf_in%lvrep(iv)
#ifdef _CUDA
                  if (v_incr == 0) then
                    if (iv + vstep - 1 <= isdf_in%lvrep_bound(jvrep,2)) then
                      v_incr_end = vstep
                    else
                      v_incr_end = isdf_in%lvrep_bound(jvrep,2) - iv + 1
                    end if
                  end if
                  v_incr = v_incr + 1
#endif
                  do jcrep = 1, gvec%syms%ntrans
                    if (gvec%syms%prod(jcrep, jvrep) == nmrep) exit
                  end do ! jcrep 
#if defined DCU
                  Nbytes = isdf_in%n_intp_r*blksz*Bytes_double
                  call hipCheck(hipMemcpy(d_cvec, c_loc(tmp_Cvec), Nbytes, 
                      hipMemcpyHostToDevice)) 
                  call hadamard_prod_mat_sym(d_PsiV, d_PsiC, d_Cmtrx, d_lcrep, &
                      isdf_in%n_intp_r, jv-1, isdf_in%mynv, isdf_in%mync, &
                      isdf_in%maxmync_sym, isdf_in%lcrep_bound(jcrep,1), 
                      isdf_in%lcrep_bound(jcrep,2)) 
                  call hipblasCheck(hipblasDgemm(handle, transt, transn, &
                      isdf_in%mync_sym(jcrep), blksz, isdf_in%n_intp_r, d_one, &
                      d_Cmtrx, isdf_in%n_intp_r, d_cvec, isdf_in%n_intp_r, &
                      d_zero, d_pvec, isdf_in%maxmync_sym))
                  call hipCheck(hipDeviceSynchronize())
                  Nbytes = isdf_in%maxmync_sym*blksz*Bytes_double
                  call hipCheck(hipMemcpy(c_loc(tmparray), d_pvec, Nbytes, &
                      hipMemcpyDeviceToHost))
#elif defined _CUDA
                  d_cvec = tmp_Cvec
                  icstart = isdf_in%lcrep_bound(jcrep,1)
                  icend   = isdf_in%lcrep_bound(jcrep,2)
                  voffset = (v_incr - 1) * isdf_in%mync_sym(jcrep)
                  istat = cudaDeviceSynchronize()
!$cuf kernel do
                  do ic = icstart, icend
                    jc = d_lcrep(ic)
                    d_Cmtrx(voffset+ic-icstart+1,1:n_intp_r) = &
                        d_PsiC(1:n_intp_r,jc) * d_PsiV(1:n_intp_r,jv)
                  end do ! ic

                  if (v_incr == v_incr_end) then
                    call cublasdgemm('N', 'N', &
                        v_incr_end*isdf_in%mync_sym(jcrep), blksz, n_intp_r, &
                        1.d0, d_Cmtrx, vstep*isdf_in%maxmync_sym, d_Cvec, &
                        isdf_in%n_intp_r, 0.d0, d_pvec, &
                        vstep*isdf_in%maxmync_sym )
                    v_incr = 0
                    tmparray = d_pvec
                    Pvec(cvstart+1:cvstart+isdf_in%mync_sym(jcrep)*v_incr_end, &
                        1:blksz) = tmparray(1:isdf_in%mync_sym(jcrep) * &
                        v_incr_end,1:blksz)
                    cvstart = cvstart + isdf_in%mync_sym(jcrep) * v_incr_end
                  end if
                  istat = cudaDeviceSynchronize()

#else
                  do ic = isdf_in%lcrep_bound(jcrep,1), &
                      isdf_in%lcrep_bound(jcrep,2)
                    jc = isdf_in%lcrep(ic)
                    tmp_Cmtrx(ic-isdf_in%lcrep_bound(jcrep,1)+1, &
                        1:isdf_in%n_intp_r) = &
                        isdf_in%PsiC_intp_bl(1:isdf_in%n_intp_r,jc,1,1) * &
                        isdf_in%PsiV_intp_bl(1:isdf_in%n_intp_r,jv,1,1)
                  end do ! ic loop
                  call dgemm('N', 'N', isdf_in%mync_sym(jcrep), blksz, &
                      isdf_in%n_intp_r, 1.d0, tmp_Cmtrx, isdf_in%maxmync_sym, &
                      tmp_Cvec, isdf_in%n_intp_r, 0.d0, tmparray, &
                      isdf_in%maxmync_sym)
#endif
#ifndef _CUDA
                  Pvec(cvstart+1:cvstart+isdf_in%mync_sym(jcrep), 1:blksz) = &
                      tmparray(1:isdf_in%mync_sym(jcrep),1:blksz)
                  cvstart = cvstart + isdf_in%mync_sym(jcrep)
#endif
                  !if (peinf%master) print *, " cvstart ", cvstart
                end do ! iv
              end do ! jvrep
              !call mpi_barrier(w_grp%comm, mpi_err)
              !ij = 0
              !if (w_grp%master) then
              !print *, " iv ic sqrtR Pvec "
              !do iv = 1, isdf_in%mynv
              !  do ic = 1, isdf_in%mync
              !    print *, iv, ic, sqrtR(ij), Pvec(ij, 1) 
              !  enddo
              !enddo
              !endif
              !call mpi_barrier(w_grp%comm, mpi_err)
              ! if (w_grp%master) print *, "sqrtR ", sqrtR(1:5)
              ! if (w_grp%master) print *, "Pvec(:,1) ", Pvec(1:5, 1)
              ! if (w_grp%master) print *, "Pvec(:,2) ", Pvec(1:5, 2)
              pnorm2 = 0.d0
              do kk = 1, blksz
                Pvec(1:isdf_in%myncv_sym(nmrep),kk) = &
                    Pvec(1:isdf_in%myncv_sym(nmrep),kk) * &
                    sqrtR(1:isdf_in%myncv_sym(nmrep))
                pnorm2(kk) = ddot(isdf_in%myncv_sym(nmrep), Pvec(1,kk), 1, &
                    Pvec(1,kk), 1)
              end do ! kk
              call MPI_ALLREDUCE(MPI_IN_PLACE, pnorm2, blksz, MPI_DOUBLE, &
                  MPI_SUM, peinf%comm, info)
              do kk = 1, blksz
                pnorm(kk) = sqrt(pnorm2(kk))
              end do ! kk
              call stopwatch(peinf%master, " Finished preparing Pvec ")
              !if (w_grp%master) print *, "pnorm**2 ", pnorm2(1:blksz)
              !stop
              if (blks(iblk,3,irep) == 1) then ! occupied states

                do kk = 1, blksz
                  jk = isdf_in%lrep(jn+kk-1)
                  ezz(1:sig_in%nen, kk) = &
                      -(zz(1:sig_in%nen)-kpt%wfn(isp,ik)%e1(jk)) &
                      + cmplx(0.d0, 1.d0) * ecuts
                end do ! kk
                ezz(sig_in%nen + 1, 1:blksz) = cmplx(0.d0, 0.d0)
                ! call lanczos_spectra to compute <Pvec| 1/(ezz-H_aux) |Pvec>
                call lanczos_spectra_isdf_lowcomsym(Pvec, pnorm, &
                    isdf_in%myncv_sym(nmrep), ezz, sig_in%nen+1, &
                    opt%lanczos_niter, isdf_in, ncv, sqrtR, polynomial, npoly, &
                    sigma_corr_tmp, &
#if defined DCU
                    blksz, nmrep, gvec, d_PsiV, d_PsiC, d_Cmtrx, d_pvec, &
                    d_cvec, d_lcrep, handle &
#elif defined _CUDA
                    blksz, nmrep, gvec, d_PsiV, d_PsiC, d_Cmtrx, d_pvec, &
                    d_cvec, d_lcrep, vstep, tmp_Cvec, streamid &
#else
                    blksz, nmrep, gvec &
#endif
                    )
                do kk = 1, blksz
                  sigma_corr(1:sig_in%nen) = sigma_corr(1:sig_in%nen) + &
                      2.0 * pnorm2(kk) * (-sigma_corr_tmp(sig_in%nen+1,kk) + &
                      sigma_corr_tmp(1:sig_in%nen,kk))/(-ezz(1:sig_in%nen,kk))
#ifdef DEBUG
                  if (peinf%master) print *, isdf_in%lrep(jn+kk-1), "incr ", &
                      (-sigma_corr_tmp(sig_in%nen+1,kk)+sigma_corr_tmp(2,kk)) &
                      / (-ezz(2,kk)) * 2.0 * pnorm2(kk)
                  if (peinf%master) then
                    do ien = 1, sig_in%nen
                      write (dbgunit, '(i7,3x,i7,3x,i7,3x,e15.5,3x,e15.5)') &
                          m1, isdf_in%lrep(jn+kk-1), ien, real(zz(ien)), &
                          real((-sigma_corr_tmp(sig_in%nen+1,kk) &
                          + sigma_corr_tmp(ien,kk)) / (-ezz(ien, kk))) &
                          * 2.0 * pnorm2(kk) *ryd 
                    end do ! ien
                  end if
#endif
                end do ! kk

              else ! for unoccupied states

                do kk = 1, blksz
                  jk = isdf_in%lrep(jn+kk-1)
                  ezz(1:sig_in%nen, kk) = &
                      (zz(1:sig_in%nen)-kpt%wfn(isp,ik)%e1(jk)) &
                      + cmplx(0.d0, 1.d0) * ecuts
                end do ! kk
                ezz(sig_in%nen+1,1:blksz) = cmplx(0.d0, 0.d0)
                ! call lanczos_spectra to compute <Pvec| 1/(ezz-H_aux) |Pvec>
                call lanczos_spectra_isdf_lowcomsym(Pvec, pnorm, &
                    isdf_in%myncv_sym(nmrep), ezz, sig_in%nen+1, &
                    opt%lanczos_niter, isdf_in, ncv, sqrtR, polynomial, npoly, &
                    sigma_corr_tmp, &
#if defined DCU
                    blksz, nmrep, gvec, d_PsiV, d_PsiC, d_Cmtrx, d_pvec, &
                    d_cvec, d_lcrep, handle &
#elif defined _CUDA
                    blksz, nmrep, gvec, d_PsiV, d_PsiC, d_Cmtrx, d_pvec, &
                    d_cvec, d_lcrep, vstep, tmp_Cvec, streamid &
#else
                    blksz, nmrep, gvec &
#endif
                    )
                do kk = 1, blksz
                  sigma_corr(1:sig_in%nen) = sigma_corr(1:sig_in%nen) + &
                      (-sigma_corr_tmp(sig_in%nen+1, kk) &
                      + sigma_corr_tmp(1:sig_in%nen, kk)) &
                      / ezz(1:sig_in%nen, kk) * 2.0 * pnorm2(kk)
#ifdef DEBUG
                  if (peinf%master) print *, isdf_in%lrep(jn+kk-1), "incr ", &
                      (-sigma_corr_tmp(sig_in%nen+1,kk) + &
                      sigma_corr_tmp(2, kk)) / ezz(2, kk) * 2.0 * pnorm2(kk)
                  if (peinf%master) then
                    do ien = 1, sig_in%nen
                      write (dbgunit, '(i7,3x,i7,3x,i7,3x,e15.5,3x,e15.5)') &
                          m1, isdf_in%lrep(jn+kk-1), ien, real(zz(ien)), &
                          real((-sigma_corr_tmp(sig_in%nen+1,kk) &
                          + sigma_corr_tmp(ien, kk)) / ezz(ien, kk)) * 2.0 &
                          * pnorm2(kk) * ryd
                    end do ! ien
                  end if
#endif
                end do ! kk
              end if

              call stopwatch(peinf%master, ' summation over bands ')
              do kk = 68, 73
                jj = 3
                call timacc(kk, jj, tsec)
                if (peinf%master) write (6, '(i3,f15.6,f15.6,a,i12)') kk, &
                    tsec(1), tsec(2), " sec", jj
              end do ! kk
              jj = 3
              call timacc(58, jj, tsec)
              if (peinf%master) write (6, '(i3,f15.6,f15.6,a,i12,a)') 58, &
                  tsec(1), tsec(2), " sec", jj, " matvec_isdf runs"
              ! stop

            end do ! iblk 

            deallocate(Pvec)

          end do ! irep

          if (peinf%master) then
            print *, "sigma_corr", sig_in%map(sig_in%diag(isig))
            do ien = 1, sig_in%nen
              write (6, '(a,i7,f15.6,f15.6,f15.6)') " #sigma_c ", ien, &
                  ryd*(deltae*(ien-1) + en0), real(sigma_corr(ien))*ryd, &
                  aimag(sigma_corr(ien))*ryd
            end do ! ien
            print *, "E_qp(E)", sig_in%map(sig_in%diag(isig))
            do ien = 1, sig_in%nen
              write (6, '(a,i7,f15.6,f15.6)') " #E_qp ", ien, &
                  ryd*(deltae*(ien-1)+en0), &
                  (kpt%wfn(1,1)%e1(m1) + real(sig(1,1)%xdiag(isig) &
                  + sigma_corr(ien) - sig(1,1)%vxcdiag(isig))) * ryd
            end do ! ien
          end if ! peinf%master
          do ien = 1, sig_in%nen
            sig(isp,ik)%scdiag(ien,isig) = real(sigma_corr(ien))
            sig(isp,ik)%scdiag(ien,sig_in%ndiag+isig) = aimag(sigma_corr(ien))
          end do ! ien
          ! sig(isp,ik)%scdiag
        end do ! isig
      end do ! isp
     end do ! ik
     deallocate (zz,ezz)
     deallocate (tmp_Cmtrx)
     deallocate (tmp_Cvec)
     deallocate (tmp_CvecM)
     deallocate (sqrtR)
     !deallocate (MC_vec)
     !deallocate (CMC_vec)
     !deallocate (tmp_vec)
     deallocate (isdf_in%PsiV_intp_bl)
     deallocate (isdf_in%PsiC_intp_bl)
     deallocate (isdf_in%vstart)
     deallocate (isdf_in%cstart)
     deallocate (isdf_in%vend)
     deallocate (isdf_in%cend)
     deallocate (tmparray)
     deallocate (tmp_count)

#ifdef DCU
     call hipCheck(hipFree(d_PsiV))
     call hipCheck(hipFree(d_PsiC))
     call hipCheck(hipFree(d_cvec))
     call hipCheck(hipFree(d_pvec))
     call hipCheck(hipFree(d_Cmtrx))
     call hipCheck(hipFree(d_lcrep))
#endif 
#ifdef _CUDA
     deallocate (d_PsiV, d_PsiC, d_cvec, d_pvec, d_cmtrx)
     deallocate (d_lcrep)
#endif
  else ! xc != GW
    print *, "lanczos method only support GW."
    call die("lanczos method only support GW. You asked for other xc type in the input file.")
  end if ! xc 
#ifdef DCU
  call hipblasCheck(hipblasDestroy(handle))
#endif
#ifdef _CUDA
  istat = cublasDestroy(handle)
#endif

#ifdef DEBUG
  ! WG: for debug
  if (peinf%master) close (dbgunit)
#endif

  call stopwatch(r_grp%master, &
      ' All matrix elements calculated. Start printout')

  if (peinf%master .and. sig_in%xc == XC_GW) then
      open (12, file='hmat_qp_nostatic', form='formatted')
  end if

  max_sig = mone

  call MPI_BARRIER(peinf%comm, info)
  !-------------------------------------------------------------------
  ! From now on, unit of energy is eV.
  !
  do ik = 1, nkpt
    do isp = 1, nspin
      jk = sig(isp,ik)%indxk
      if (sig(isp,ik)%ndiag_s > 0) then
          sig(isp,ik)%vxcdiag = sig(isp,ik)%vxcdiag * ryd
          sig(isp,ik)%xdiag = sig(isp,ik)%xdiag * ryd
          sig(isp,ik)%scsdiag = sig(isp,ik)%scsdiag * ryd
      end if
      if (sig(isp,ik)%noffd_s > 0) then
          sig(isp,ik)%vxcoffd = sig(isp,ik)%vxcoffd * ryd
          sig(isp,ik)%xoffd = sig(isp,ik)%xoffd * ryd
          sig(isp,ik)%scsoffd = sig(isp,ik)%scsoffd * ryd
      end if
      if (sig_in%xc == XC_GW) then
         if (sig(isp,ik)%ndiag_s > 0) &
             sig(isp,ik)%sgsdiag = sig(isp,ik)%sgsdiag * ryd
         if (sig(isp,ik)%noffd_s > 0) &
             sig(isp,ik)%sgsoffd = sig(isp,ik)%sgsoffd * ryd
         if (sig(isp,ik)%ndiag > 0) then
             sig(isp,ik)%scdiag = sig(isp,ik)%scdiag * ryd
             sig(isp,ik)%sexdiag = sig(isp,ik)%sexdiag * ryd
             sig(isp,ik)%sgdiag = sig(isp,ik)%sgdiag * ryd
         end if
         if (sig(isp,ik)%noffd > 0) then
            sig(isp,ik)%scoffd = sig(isp,ik)%scoffd * ryd
            sig(isp,ik)%sgoffd = sig(isp,ik)%sgoffd * ryd
         end if
      end if

      !-------------------------------------------------------------------
      ! Sort quasiparticle orbitals according to representation.
      !
      allocate (iord(sig(isp,ik)%nmap))
      iord = 0
      do irp = 1, gvec%syms%ntrans
        jj = 0
        do isig = 1, sig(isp,ik)%nmap
          ii = sig(isp,ik)%map(isig)
          if (kpt%wfn(isp,jk)%irep(ii) == irp) then
            jj = jj + 1
            iord(isig) = jj
          end if
        end do ! isig
        neig_qp = jj
        q_p(irp,isp,ik)%neig = neig_qp
        if (neig_qp > 0) then
          allocate (q_p(irp,isp,ik)%jrep(neig_qp))
          q_p(irp,isp,ik)%jrep = 0
          allocate (q_p(irp,isp,ik)%hqp(neig_qp,neig_qp))
          q_p(irp,isp,ik)%hqp = zzero
          allocate (q_p(irp,isp,ik)%sigmaqp(neig_qp,neig_qp))
          q_p(irp,isp,ik)%sigmaqp = zzero
          allocate (q_p(irp,isp,ik)%sigmai(neig_qp))
          q_p(irp,isp,ik)%sigmai = ecuts * ryd
          allocate (q_p(irp,isp,ik)%eqp(neig_qp))
          q_p(irp,isp,ik)%eqp = zero
          allocate (q_p(irp,isp,ik)%vqp(neig_qp,neig_qp))
          q_p(irp,isp,ik)%vqp = zzero
          jj = 0
          do isig = 1, sig(isp,ik)%nmap
            ii = sig(isp,ik)%map(isig)
            if (kpt%wfn(isp,jk)%irep(ii) == irp) then
              jj = jj + 1
              q_p(irp,isp,ik)%jrep(jj) = ii
              q_p(irp,isp,ik)%hqp(jj,jj) = zone*kpt%wfn(isp,jk)%e1(ii)*ryd
            end if
          end do ! isig
        end if
      end do ! irp
      !-------------------------------------------------------------------
      ! Print self-energy corrections.
      !
      if (gvec%per > 0) then
        if (nspin == 1) then
          write (file_name, '(a,i3.3,a,i4.4)') 'sigma_nostatic_', ik, '_', &
              it_scf
        else
          if (isp == 1) then
            write (file_name, '(a,i3.3,a,i4.4)') 'sigma_nostatic_up_', ik, &
                '_', it_scf
          else
            write (file_name, '(a,i3.3,a,i4.4)') 'sigma_nostatic_down_', ik, &
                '_', it_scf
          end if
        end if
      else
        if (nspin == 1) then
          write (file_name, '(a,i3.3,a,i4.4)') 'sigma_nostatic_', ik, '_', &
              it_scf
        else
           if (isp == 1) then
             write (file_name, '(a,i3.3,a,i4.4)') 'sigma_nostatic_up_', ik, &
                 '_', it_scf
           else
             write (file_name, '(a,i3.3,a,i4.4)') 'sigma_nostatic_down_', ik, &
                 '_', it_scf
           end if
        end if
      end if
      !
      ! Print self-energy tables without static correction.
      !
      call printsigma(gvec%syms%ntrans, sig_in,sig(isp,ik), kpt%wfn(isp,jk), &
          q_p(1:gvec%syms%ntrans,isp,ik), 12, isp, ik, iord, qpmix, rtmp, &
          file_name)

      deallocate(iord)
    end do ! isp
  end do ! ik

  if (peinf%master .and. sig_in%xc == XC_GW) then
    close (12)
  end if
#ifdef MPI
  call MPI_BCAST(max_sig, 1, MPI_DOUBLE_PRECISION, peinf%masterid, peinf%comm, &
      info)
#endif

  !-------------------------------------------------------------------
  ! Calculate total energy.
  !
  !call Zetotal(gvec,kpt,nspin)

  if (writeqp .and. sig_in%xc == XC_GW .and. dft_code == PARSEC) &
      call Zprint_qp(nspin, gvec%syms%ntrans, 66, 77, gvec, kpt)

end subroutine Zcalculate_sigma_lanczos_lowcomsym
!===================================================================


